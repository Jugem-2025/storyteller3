<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FENG SHUI MASTER</title>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #E81F27;
            color: black;
            font-family: 'Oswald', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* 画面外に落ちる文字のためにoverflowを許可することも検討可能ですが、今回は画面外に隠れるようにhiddenを維持します */
            position: relative;
            perspective: 1000px; /* 3D効果のために追加 */
        }

        .text-container {
            position: relative;
            width: 90vw; /* 画面幅に合わせて調整 */
            max-width: 1200px; /* 最大幅を設定 */
            text-align: center;
            line-height: 1.2;
            word-break: break-word; /* 長い単語の途中で改行 */
            white-space: normal; /* 折り返しを有効にする */
            font-size: 3vw; /* フォントサイズ */
            pointer-events: none; /* クリックイベントを無効化 */
        }

        .char {
            display: inline-block;
            opacity: 1;
            transform: translateZ(0); /* GPUアクセラレーションを有効にする */
            will-change: transform, opacity; /* アニメーションの最適化 */
            position: relative; /* アニメーション中に位置を正確に把握するため */
        }

        /* 文字が落下して止まるアニメーション */
        @keyframes fall-and-hold {
            0% {
                opacity: 1;
                transform: translateY(0) rotate(0deg) scale(1);
            }
            80% { /* 停止位置に到達 */
                transform: translateY(var(--target-y-offset)) rotate(var(--rotate-deg)) scale(0.9);
                opacity: 1;
            }
            100% { /* 停止状態を維持 */
                transform: translateY(var(--target-y-offset)) rotate(var(--rotate-deg)) scale(0.9);
                opacity: 1;
            }
        }

        /* 最終的なstorytellerの形を形成する文字のスタイル */
        .storyteller-char {
            position: absolute;
            opacity: 0; /* 最初は透明 */
            color: black;
            font-family: 'Oswald', sans-serif;
            pointer-events: none;
            transition: transform 1.5s ease-in-out, opacity 1.5s ease-in-out; /* ヌルッと集まるアニメーション */
            font-size: 3vw; /* 元の文字サイズを保持 */
            z-index: 2; /* 通常の文字より前面に */
        }

        /* 最終的に固定されるstorytellerのフォント */
        .final-storyteller-text {
            position: absolute;
            font-family: 'Oswald', sans-serif;
            font-weight: 500;
            font-size: 10vw; /* 大きく表示 */
            color: black;
            opacity: 0; /* 最初は透明 */
            z-index: 100; /* 最前面に表示 */
            white-space: nowrap; /* 改行させない */
            transition: all 1.5s ease-in-out; /* ヌルッと移動・拡大 */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5); /* 初期状態は小さく中央に */
        }
    </style>
</head>
<body>
    <div class="text-container" id="textContainer"></div>
    <div class="final-storyteller-text" id="finalStorytellerText">storyteller</div>

    <script>
        const originalText = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`;

        const textContainer = document.getElementById('textContainer');
        const finalStorytellerText = document.getElementById('finalStorytellerText');
        let chars = []; // 全ての文字要素を格納する配列
        let storytellerChars = []; // 「storyteller」を形成する文字要素の配列

        // ③ ページ表示時に文章を表示
        function initializeText() {
            originalText.split('').forEach(char => {
                const span = document.createElement('span');
                span.className = 'char';
                span.textContent = char;
                textContainer.appendChild(span);
                chars.push(span);
            });
        }

        // 「storyteller」の形を形成するためのターゲット座標を計算
        function getStorytellerTargetPositions(word, charElements) {
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.opacity = '0';
            tempDiv.style.fontFamily = 'Oswald, sans-serif';
            tempDiv.style.fontWeight = '500';
            tempDiv.style.fontSize = '10vw';
            tempDiv.style.whiteSpace = 'nowrap';
            tempDiv.textContent = word;
            document.body.appendChild(tempDiv);

            const rect = tempDiv.getBoundingClientRect();
            const textWidth = rect.width;
            const textHeight = rect.height;

            const charWidth = textWidth / word.length;
            const charHeight = textHeight;

            let positions = [];
            for (let i = 0; i < word.length; i++) {
                positions.push({
                    left: window.innerWidth / 2 - textWidth / 2 + i * charWidth,
                    top: window.innerHeight / 2 - textHeight / 2
                });
            }
            document.body.removeChild(tempDiv);
            return positions;
        }

        // ④ 文字がバラバラと崩れ落ちるアニメーション
        function startFallingAnimation() {
            const containerRect = textContainer.getBoundingClientRect();
            const bodyRect = document.body.getBoundingClientRect();

            // 落下開始の基準点 (画面中央上部の左4分の1くらい)
            const startPointX = window.innerWidth / 2 - containerRect.width / 4;
            const startPointY = containerRect.top + containerRect.height / 4; // 上の方から開始

            // storytellerの最終的な文字位置を事前に計算
            const storytellerWord = "storyteller";
            const storytellerTargetPositions = getStorytellerTargetPositions(storytellerWord, chars);
            let charIndicesForStoryteller = [];

            // どの文字をstorytellerに使うかランダムに選択（重複なし）
            while (storytellerChars.length < storytellerWord.length) {
                const randomIndex = Math.floor(Math.random() * chars.length);
                if (!charIndicesForStoryteller.includes(randomIndex)) {
                    storytellerChars.push(chars[randomIndex]);
                    charIndicesForStoryteller.push(randomIndex);
                }
            }

            chars.forEach((char, index) => {
                const charRect = char.getBoundingClientRect();
                const initialTop = charRect.top - bodyRect.top; // ボディの上端からの相対位置
                const initialLeft = charRect.left - bodyRect.left; // ボディの左端からの相対位置

                const delay = 3000 + Math.random() * 2000; // 3秒後からランダムに2秒追加
                const animationDuration = 6000 + Math.random() * 2000; // 6秒〜8秒かけて落下

                // 落下開始の伝播遅延を基準点からの距離で計算
                const currentCharCenterX = initialLeft + charRect.width / 2;
                const currentCharCenterY = initialTop + charRect.height / 2;
                const distanceFromStartPoint = Math.sqrt(
                    Math.pow(currentCharCenterX - startPointX, 2) +
                    Math.pow(currentCharCenterY - startPointY, 2)
                );
                const propagationDelay = (distanceFromStartPoint / Math.max(window.innerWidth, window.innerHeight)) * 2000; // 最大2秒の伝播遅延
                const finalDelay = delay + propagationDelay;

                const rotateDeg = (Math.random() - 0.5) * 720; // -360degから360degの回転
                const translateX = (Math.random() - 0.5) * 50; // 左右の揺れ

                // 落下中のランダムな一時停止位置 (画面全体の30%〜70%の高さの範囲)
                const stopY = window.innerHeight * (0.3 + Math.random() * 0.4);

                // ⑤ 積もる位置は、画面の表示されている部分(相対サイズ)の下から20パーセントまで
                // 元々の文字の位置が20パーセントより下のものは、画面外下方向に落ちていくようにする。
                const bottom20PercentMark = window.innerHeight * 0.8;
                let finalDropY; // 最終的な落下位置 (初期位置からのオフセット)

                if (initialTop > bottom20PercentMark) {
                    // 画面下20%より下にある文字は画面外へ落下
                    finalDropY = (window.innerHeight + charRect.height) - initialTop; // 画面外に完全に落ちるように
                } else {
                    // それ以外の文字はランダムな停止位置 (stopY) に留まるか、下部20%に積もる
                    finalDropY = stopY - initialTop; // stopYは絶対座標なので、initialTopからの相対オフセットを計算
                }

                char.style.setProperty('--target-y-offset', `${finalDropY}px`);
                char.style.setProperty('--rotate-deg', `${rotateDeg}deg`);

                // 適用するアニメーション
                char.style.animation = `fall-and-hold ${animationDuration / 1000}s ease-out ${finalDelay / 1000}s forwards`;

                // 崩れ落ちた文字をその位置に固定する処理
                setTimeout(() => {
                    char.style.position = 'absolute';
                    char.style.left = `${initialLeft + translateX}px`;
                    char.style.top = `${initialTop + finalDropY}px`; // 初期位置 + 移動オフセットで最終位置
                    char.style.opacity = '1';
                    char.style.transform = `translateZ(0) rotate(${rotateDeg}deg) scale(0.9)`;
                    // ここではまだstoryteller-charクラスは付与しない
                    char.style.animation = 'none'; // アニメーションを解除
                }, finalDelay + animationDuration);
            });

            // ⑥ 「storyteller」の輪郭を浮かび上がらせる処理
            // 全ての文字の落下と停止が終わるであろう時間
            const totalFallCompletionTime = 3000 + 2000 + 8000; // 最小開始遅延 + 最大伝播遅延 + 最大アニメーション時間

            setTimeout(() => {
                storytellerChars.forEach((char, i) => {
                    // 各文字を「storyteller」の形を構成する位置へ移動
                    const targetPos = storytellerTargetPositions[i];
                    char.classList.add('storyteller-char'); // storytellerの文字としてスタイルを適用
                    char.textContent = storytellerWord[i]; // 対応するstorytellerの文字に置き換え (見た目上)

                    // ヌルッと集まるアニメーション
                    char.style.left = `${targetPos.left}px`;
                    char.style.top = `${targetPos.top}px`;
                    char.style.opacity = '1'; // 透明から表示へ
                    char.style.transform = 'translateZ(0) rotate(0deg) scale(1)'; // 正しい向きとサイズへ
                });

                // 「storyteller」のテキスト自体を中央に表示
                setTimeout(() => {
                    finalStorytellerText.style.opacity = '1';
                    finalStorytellerText.style.transform = 'translate(-50%, -50%) scale(1)'; // 中央に移動し、元のサイズに戻す
                }, 1500); // storytellerCharsが集まりきるのを待つ
            }, totalFallCompletionTime);
        }

        initializeText();
        // 3秒後にアニメーションを開始
        setTimeout(startFallingAnimation, 3000);
    </script>
</body>
</html>
